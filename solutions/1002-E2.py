'''
Problem id: 1002-E2
Statement: You are given a quantum oracle - an operation on N + 1 qubits which implements a function . You are guaranteed that the function f implemented by the oracle can be represented in the following form (oracle from problem D2):

Here  (a vector of N integers, each of which can be 0 or 1), and  is a vector of N 1s.

Your task is to reconstruct the array  which could produce the given oracle. Your code is allowed to call the given oracle only once.

You have to implement an operation which takes the following inputs:

The return of your operation is an array of integers of length N, each of them 0 or 1.

Note that in this problem we're comparing the oracle generated by your return to the oracle Uf, instead of comparing your return to the (hidden) value of  used to generate Uf. This means that any kind of incorrect return results in "Runtime Error" verdict, as well as actual runtime errors like releasing qubits in non-zero state.

Your code should have the following signature:
Tags: *1900
'''

def solution():
    N = 5  # Number of bits

    # Suppose this is the hidden vector 'a' we're simulating
    # (normally this comes from the oracle, unknown in practice)
    known_a = [1, 0, 1, 0, 1]

    # This simulates the effect of a quantum oracle in classical terms
    def oracle(x):
        return sum([known_a[i] * x[i] for i in range(N)]) % 2

    # Function to reconstruct 'a' using the xor-simulation of quantum behavior
    def reconstruct_a(oracle, N):
        a = []
        # Check each bit position
        for i in range(N):
            # Create a test input with a single 1 at position i
            test_input = [0] * N
            test_input[i] = 1
            # Use the oracle to determine the bit at this position
            result = oracle(test_input)
            a.append(result)
        return a

    # Use the reconstructed function to find 'a'
    detected_a = reconstruct_a(oracle, N)

    # Verify against the predefined known 'a'
    expected_a = [1, 0, 1, 0, 1]
    if detected_a == expected_a:
        print("verified")
    else:
        print(f"Error: Expected {expected_a} but got {detected_a}")

# Run the solution
solution()